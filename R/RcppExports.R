# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculating penalty matrix
#' 
#' This function calculates the penalty matrix for a given number of 
#' parameters (`nparams`) and a given number of differences (`differences`).
#' 
#' @param nparams `unsigned int` Number of params which should be penalized.
#'   This also pretend the number of rows and columns.
#'   
#' @param differences `unsigned int` Number of penalized differences.
#' 
#' @return `arma::sp_mat` Sparse penalty matrix used for p splines. 
#' @examples
#' pen = penaltyMat(10, 2)
#' @export
penaltyMat <- function(nparams, differences) {
    .Call(`_compboostSplines_penaltyMat`, nparams, differences)
}

#' Binary search to find index of given point within knots
#' 
#' This small functions search for the position of `x` within the
#' `knots` and returns the smalles index for which x >= knots[i].
#' 
#' Note that this function returns the `C++` index which starts 
#' with `0` and ends with `n-1`.
#'
#' @param x `double` Point to search for position in knots.
#' @param knots `arma::vec` Vector of knots. It's the users responsibility to
#'   pass a **SORTED** vector.
#' @return `unsigned int` of position of `x` in `knots`.
#' @examples
#' knots = 1:10
#' findSpan(1, knots)
#' findSpan(2.5, knots)
#' findSpan(9.5, knots)
#' findSpan(10, knots)
#' @export
findSpan <- function(x, knots) {
    .Call(`_compboostSplines_findSpan`, x, knots)
}

#' Create knots for a specific number, degree and values
#' 
#' This functions takes a vector of points and creates knots used for the
#' splines depending on the number of knots and degree. This function just
#' handles equidistant knots.
#' 
#' @param values `arma::vec` Points to create the basis matrix.
#' @param n_knots `unsigned int` Number of innter knots.
#' @param degree `unsigned int` polynomial degree of splines.
#'    
#' @return `arma::vec` of knots.
#' @examples
#' x = sort(runif(100, 0, 10))
#' y = 2 * sin(x) + rnorm(100, 0, 0.5)
#' 
#' # Create knots on the space of x:
#' knots = createKnots(values = x, n_knots = 7, degree = 3)
#' @export
createKnots <- function(values, n_knots, degree) {
    .Call(`_compboostSplines_createKnots`, values, n_knots, degree)
}

#' De Boors algorithm to find basis functions
#' 
#' @param x `double` Point to search for position in knots.
#' @param degree `unsigned int` Degree of the polynomial between the knots.
#' @param knots `arma::vec` Vector of knots. It's the users responsibility to
#'   pass a **SORTED** vector.
#'   
#' @return `arma::mat` dense matrix containing the basis functions.
#' @examples
#' x = sort(runif(100, 0, 10))
#' y = 2 * sin(x) + rnorm(100, 0, 0.5)
#' 
#' # Create knots on the space of x:
#' knots = createKnots(values = x, n_knots = 7, degree = 3)
#' 
#' # Create basis functions for one value:
#' basisFuns(x = x[30], degree = 3, knots = knots)
#' @export
createBasis <- function(values, degree, knots) {
    .Call(`_compboostSplines_createBasis`, values, degree, knots)
}

#' Transformation from a vector of input points to sparse matrix of basis
#' 
#' This functions takes a vector of points and create a sparse matrix of
#' basis functions. Each row contains the basis of the corresponding value 
#' in `values`.
#'
#' Instead of calculating each row through a helper function we directly 
#' calculate deboors algorithm here. This is due to the procedure how 
#' sparse matrices should be allocated and constructed.
#' 
#' @param values `arma::vec` Points to create the basis matrix.
#' @param n_knots `unsigned int` Number of innter knots.
#' @param degree `unsigned int` polynomial degree of splines.
#'    
#' @return `arma::sp_mat` sparse matrix of base functions.
#' @examples
#' nsim = 100
#' 
#' x = sort(runif(nsim, 0, 10))
#' y = 2 * sin(x) + rnorm(nsim, 0, 0.5) 
#' knots = createKnots(values = x, n_knots = 20, degree = 3)
#'
#' # Create spline basis:
#' basis = createSparseBasis(values = x, degree = 3, knots = knots)
#' @export
createSparseBasis <- function(values, degree, knots) {
    .Call(`_compboostSplines_createSparseBasis`, values, degree, knots)
}

